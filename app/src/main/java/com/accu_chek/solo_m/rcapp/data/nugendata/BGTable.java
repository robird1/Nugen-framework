/** 
 * ===========================================================================
 * Copyright 2015 Roche Diagnostics GmbH
 * All Rights Reserved
 * ===========================================================================
 *
 * Class name: com.accu_chek.solo_m.rcapp.data.nugendata.BGTable
 * Brief: 
 *      write by myself...
 * Create Date: 2015/6/1
 * $Revision: 23975 $
 * $Author: SteveSu $
 * $Id: BGTable.java 23975 2015-11-12 08:40:25Z SteveSu $
 */
package com.accu_chek.solo_m.rcapp.data.nugendata;

import java.util.ArrayList;

import android.content.ContentValues;
import android.database.Cursor;
import android.net.Uri;

import com.accu_chek.solo_m.rcapp.application.safety.SafetyChannel;
import com.accu_chek.solo_m.rcapp.application.util.CommonUtils;
import com.accu_chek.solo_m.rcapp.application.util.Debug;
import com.accu_chek.solo_m.rcapp.data.operationhandler.AbstractTable;
import com.accu_chek.solo_m.rcapp.data.operationhandler.IDBData;

public class BGTable extends AbstractTable
{
    // Table column name. This column value will be generated automatically by
    // Android.
    public static final String COLUMN_BG_ID = "bg_id";
    
    // Table column name. This column value can be null when inserting.
    public static final String COLUMN_BG_VALUE = "bg_value";
    
    // Table column name. This column value must not be null when inserting or
    // an SQLiteException will occur.
    public static final String COLUMN_SEGMENT_ID = "segment_id";
    
    // Table column name. This column value must not be null when inserting or
    // an SQLiteException will occur.
    public static final String COLUMN_TIMESTAMP = "timestamp";
    
    // Table column name. This column value must not be null when inserting or
    // an SQLiteException will occur.
    public static final String COLUMN_TIMESTAMP_DB = "timestamp_db";
    
    // Table column name. This column value must not be null when inserting or
    // an SQLiteException will occur.
    public static final String COLUMN_IS_PAIRED_TO_PUMP = "is_paired_to_pump";
    
    // Table column name. This column value must not be null when inserting or
    // an SQLiteException will occur.
    public static final String COLUMN_TEMP_RESULT = "temp_result";
    
    // Table column name. This column value must not be null when inserting or
    // an SQLiteException will occur.
    public static final String COLUMN_USER_SETTING_ID = "user_setting_id";
    
    // Table column name. This column value can be null when inserting.
    public static final String COLUMN_BG_RESULT = "bg_result";
    
    // The ID of the current queried record generated by Android.
    private int mRecordId = -1;
    
    // Table column value encoded in JSON string type.
    private String mBgValue = EMPTY_COLUMN_VALUE;
    
    // Table column value encoded in JSON string type.
    private String mSegmentId = EMPTY_COLUMN_VALUE;
    
    // Table column value encoded in JSON string type.
    private String mTimestamp = EMPTY_COLUMN_VALUE;
    
    // Table column value encoded in JSON string type.
    private String mIsPairedtoPump = EMPTY_COLUMN_VALUE;
    
    // Table column value encoded in JSON string type.
    private String mTempResult = EMPTY_COLUMN_VALUE;
    
    // Table column value encoded in JSON string type.
    private String mUserSettingId = EMPTY_COLUMN_VALUE;
    
    // Table column value encoded in JSON string type.
    private String mBgResult = EMPTY_COLUMN_VALUE;
    
    
    /**
     * Obtain column value.
     * 
     * @return Returns an object which stores the values of channel 1 and
     *         channel 2.
     *         Range: valid object
     *         Unit: SafetyChannel
     *         Scaling: 1
     * 
     * @see mRecordId: Use this global variable for storing column value.
     * 
     */
    public SafetyChannel<Integer> getRecordId()
    {
        SafetyChannel<Integer> channel = CommonUtils
                .getSafetyChannel(mRecordId);

        return channel;
    }

    /**
     * Obtain column value.
     * 
     * @return Returns an object which stores the values of channel 1 and
     *         channel 2.
     *         Range: valid object
     *         Unit: SafetyChannel
     *         Scaling: 1
     * 
     * @see mBgValue: Use this global variable for storing column value.
     * 
     */
    public SafetyChannel<Integer> getBgValue()
    {
        SafetyChannel<Integer> channel = null;

        if (!EMPTY_COLUMN_VALUE.equals(mBgValue))
        {
            int[] channelValue = DatabaseUtil.restoreChannelIntValue(mBgValue);
            channel = new SafetyChannel<Integer>(channelValue[0],
                    channelValue[1]);
        }

        return channel;
    }
    
    /**
     * Obtain column value.
     * 
     * @return Returns an object which stores the values of channel 1 and
     *         channel 2.
     *         Range: valid object
     *         Unit: SafetyChannel
     *         Scaling: 1
     * 
     * @see mSegmentId: Use this global variable for storing column value.
     * 
     */
    public SafetyChannel<Integer> getSegmentId()
    {
        SafetyChannel<Integer> channel = null;

        if (!EMPTY_COLUMN_VALUE.equals(mSegmentId))
        {
            int[] channelValue = DatabaseUtil
                    .restoreChannelIntValue(mSegmentId);
            channel = new SafetyChannel<Integer>(channelValue[0],
                    channelValue[1]);
        }

        return channel;
    }

    /**
     * Obtain column value.
     * 
     * @return Returns an object which stores the values of channel 1 and
     *         channel 2.
     *         Range: valid object
     *         Unit: SafetyChannel
     *         Scaling: 1
     * 
     * @see mTimestamp: Use this global variable for storing column value.
     * 
     */
    public SafetyChannel<Long> getTimestamp()
    {
        SafetyChannel<Long> channel = null;

        if (!EMPTY_COLUMN_VALUE.equals(mTimestamp))
        {
            long[] channelValue = DatabaseUtil
                    .restoreChannelLongValue(mTimestamp);
            channel = new SafetyChannel<Long>(channelValue[0], channelValue[1]);
        }

        return channel;
    }

    /**
     * Obtain column value.
     * 
     * @return Returns an object which stores the values of channel 1 and
     *         channel 2.
     *         Range: valid object
     *         Unit: SafetyChannel
     *         Scaling: 1
     * 
     * @see mIsPairedtoPump: Use this global variable for storing column value.
     * 
     */
    public SafetyChannel<Integer> getIsPairedtoPump()
    {
        SafetyChannel<Integer> channel = null;

        if (!EMPTY_COLUMN_VALUE.equals(mIsPairedtoPump))
        {
            int[] channelValue = DatabaseUtil
                    .restoreChannelIntValue(mIsPairedtoPump);
            channel = new SafetyChannel<Integer>(channelValue[0],
                    channelValue[1]);
        }

        return channel;
    }

    /**
     * Obtain column value.
     * 
     * @return Returns an object which stores the values of channel 1 and
     *         channel 2.
     *         Range: valid object
     *         Unit: SafetyChannel
     *         Scaling: 1
     * 
     * @see mTempResult: Use this global variable for storing column value.
     * 
     */
    public SafetyChannel<Integer> getTempResult()
    {
        SafetyChannel<Integer> channel = null;

        if (!EMPTY_COLUMN_VALUE.equals(mTempResult))
        {
            int[] channelValue = DatabaseUtil
                    .restoreChannelIntValue(mTempResult);
            channel = new SafetyChannel<Integer>(channelValue[0],
                    channelValue[1]);
        }

        return channel;
    }

    /**
     * Obtain column value.
     * 
     * @return Returns an object which stores the values of channel 1 and
     *         channel 2.
     *         Range: valid object
     *         Unit: SafetyChannel
     *         Scaling: 1
     * 
     * @see mUserSettingId: Use this global variable for storing column value.
     * 
     */
    public SafetyChannel<Integer> getUserSettingId()
    {
        SafetyChannel<Integer> channel = null;

        if (!EMPTY_COLUMN_VALUE.equals(mUserSettingId))
        {
            int[] channelValue = DatabaseUtil
                    .restoreChannelIntValue(mUserSettingId);
            channel = new SafetyChannel<Integer>(channelValue[0],
                    channelValue[1]);
        }

        return channel;
    }

    /**
     * Obtain column value.
     * 
     * @return Returns an object which stores the values of channel 1 and
     *         channel 2.
     *         Range: valid object
     *         Unit: SafetyChannel
     *         Scaling: 1
     * 
     * @see mBgResult: Use this global variable for storing column value.
     * 
     */
    public SafetyChannel<Integer> getBgResult()
    {
        SafetyChannel<Integer> channel = null;

        if (!EMPTY_COLUMN_VALUE.equals(mBgResult))
        {
            int[] channelValue = DatabaseUtil.restoreChannelIntValue(mBgResult);
            channel = new SafetyChannel<Integer>(channelValue[0],
                    channelValue[1]);
        }

        return channel;
    }

    /**
     * Obtain table column values from the values generated by the BGM process
     * to initialize the global variables for database operation (the insert or
     * update operation).
     * 
     * @param values : the values generated by the BGM process from the insert
     *            or update operation
     *            Range: valid object
     *            Unit: ContentValues
     *            Scaling: 1
     * 
     * @return None
     * 
     * @see mBgValue: Use this global variable for storing column value.
     * @see mSegmentId: Use this global variable for storing column value.
     * @see mTimestamp: Use this global variable for storing column value.
     * @see mIsPairedtoPump: Use this global variable for storing column value.
     * @see mTempResult: Use this global variable for storing column value.
     * @see mUserSettingId: Use this global variable for storing column value.
     * @see mBgResult: Use this global variable for storing column value.
     */
    @Override
    protected void getDataFromContentValue(ContentValues values)
    {
        CommonUtils.objectCheck(values);

        mBgValue = DatabaseUtil.getStringValue(values, COLUMN_BG_VALUE,
                mBgValue);
        mSegmentId = DatabaseUtil.getStringValue(values, COLUMN_SEGMENT_ID,
                mSegmentId);
        mTimestamp = DatabaseUtil.getStringValue(values, COLUMN_TIMESTAMP,
                mTimestamp);
        mIsPairedtoPump = DatabaseUtil.getStringValue(values,
                COLUMN_IS_PAIRED_TO_PUMP, mIsPairedtoPump);
        mTempResult = DatabaseUtil.getStringValue(values, COLUMN_TEMP_RESULT,
                mTempResult);
        mUserSettingId = DatabaseUtil.getStringValue(values,
                COLUMN_USER_SETTING_ID, mUserSettingId);
        mBgResult = DatabaseUtil.getStringValue(values, COLUMN_BG_RESULT,
                mBgResult);

    }

    /**
     * Generate record CRC value according to the values of record data.
     * 
     * @return the generated CRC value
     *            Range: -2^31 to (2^31)-1
     *            Unit: int
     *            Scaling: 1
     * 
     * @see mBgValue: Use this global variable for storing column value.
     * @see mSegmentId: Use this global variable for storing column value.
     * @see mTimestamp: Use this global variable for storing column value.
     * @see mIsPairedtoPump: Use this global variable for storing column value.
     * @see mTempResult: Use this global variable for storing column value.
     * @see mUserSettingId: Use this global variable for storing column value.
     * @see mBgResult: Use this global variable for storing column value.
     */
    @Override
    public int generateCRC()
    {
        int nCRC = -1;
        ArrayList<String> list = new ArrayList<String>();

        list.add(mBgValue);
        list.add(mSegmentId);
        list.add(mTimestamp);
        list.add(mIsPairedtoPump);
        list.add(mTempResult);
        list.add(mUserSettingId);
        list.add(mBgResult);
        
        nCRC = DatabaseUtil.generateCRC(list);
        Debug.printI("QueryCommand", "genCRC() in BGTable. nCRC: "+ nCRC);

        return nCRC;
    }

    /**
     * Invoke this method to obtain the URI path of a certain table.
     * 
     * @return the URI reference of a certain table
     *            Range: valid object
     *            Unit: Uri
     *            Scaling: 1
     */
    @Override
    public Uri onUri()
    {
        return UrlType.bgUri;
    }

    /**
     * Obtain the query record by cursor.
     * 
     * @param cursor : position to the entry of database table
     *            Range: valid object
     *            Unit: Cursor
     *            Scaling: 1
     * 
     * @return the query record
     *         Range: valid object
     *         Unit: IDBData
     *         Scaling: 1
     * 
     * @see mBgValue: Use this global variable for storing column value.
     * @see mSegmentId: Use this global variable for storing column value.
     * @see mTimestamp: Use this global variable for storing column value.
     * @see mIsPairedtoPump: Use this global variable for storing column value.
     * @see mTempResult: Use this global variable for storing column value.
     * @see mUserSettingId: Use this global variable for storing column value.
     * @see mBgResult: Use this global variable for storing column value.
     * @see mCRC: Use this global variable for storing calculated CRC value.
     */
    @Override
    public IDBData onQueryDataFromCursor(Cursor cursor)
    {
        BGTable model = null;
        
        CommonUtils.objectCheck(cursor);
        
        int recordIdIndex = cursor.getColumnIndex(COLUMN_BG_ID);
        int bgValueIndex = cursor.getColumnIndex(COLUMN_BG_VALUE);
        int segmentidIndex = cursor.getColumnIndex(COLUMN_SEGMENT_ID);
        int timestampIndex = cursor.getColumnIndex(COLUMN_TIMESTAMP);
        int isPairedToPumpIndex = cursor
                .getColumnIndex(COLUMN_IS_PAIRED_TO_PUMP);
        int tempResultIndex = cursor.getColumnIndex(COLUMN_TEMP_RESULT);
        int userSettingIdIndex = cursor.getColumnIndex(COLUMN_USER_SETTING_ID);
        int bGResultIndex = cursor.getColumnIndex(COLUMN_BG_RESULT);
        int crcIndex = cursor.getColumnIndex(COLUMN_CRC);

        model = new BGTable();

        model.mRecordId = cursor.getInt(recordIdIndex);
        model.mBgValue = DatabaseUtil.getStringValue(cursor, bgValueIndex);
        model.mSegmentId = DatabaseUtil.getStringValue(cursor, segmentidIndex);
        model.mTimestamp = DatabaseUtil.getStringValue(cursor, timestampIndex);
        model.mIsPairedtoPump = DatabaseUtil.getStringValue(cursor,
                isPairedToPumpIndex);
        model.mTempResult = DatabaseUtil
                .getStringValue(cursor, tempResultIndex);
        model.mUserSettingId = DatabaseUtil.getStringValue(cursor,
                userSettingIdIndex);
        model.mBgResult = DatabaseUtil.getStringValue(cursor, bGResultIndex);
        model.setCRC(DatabaseUtil.getIntValue(cursor, crcIndex));
        
        return model;
    }

    /**
     * Obtain the primary key name of a certain table for the update operation.
     * 
     * @return the primary key name of a certain table
     *         Range: valid object
     *         Unit: String
     *         Scaling: 1
     */
    @Override
    public String getPrimaryKeyName()
    {
        return BGTable.COLUMN_BG_ID;
    }

    /**
     * Obtain the name of a certain table for the database operation.
     * 
     * @return the name of a certain table
     *         Range: valid object
     *         Unit: String
     *         Scaling: 1
     */
    @Override
    protected String getTableName()
    {
        return DBHelper.BG_TABLE;
    }
}
