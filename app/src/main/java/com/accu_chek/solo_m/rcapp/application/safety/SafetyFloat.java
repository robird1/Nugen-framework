/**
 * ===========================================================================
 * Copyright 2013 Roche Diagnostics GmbH
 * All Rights Reserved
 * ===========================================================================
 *
 * Class name: com.accu_chek.cgmapp.application.safety.SafetyFloat
 * Brief: The class to keep the float type data by diverse way. The diverse data
 * will be kept as string type. When get() function called, it will return the
 * kept original type data if the string type value of original data is equals
 * to the value of diverse data. If two values are not equal, it will throw
 * DataIntegrityException.
 *
 * Create Date: 2014/4/22
 * $Revision: 24202 $
 * $Author: StanleySu $
 * $Id: SafetyFloat.java 24202 2015-11-16 10:18:10Z StanleySu $
 */

package com.accu_chek.solo_m.rcapp.application.safety;

import android.os.Parcel;
import android.os.Parcelable;

import com.accu_chek.solo_m.rcapp.application.exception.DataIntegrityException;

import java.io.Serializable;

public class SafetyFloat implements Serializable, Parcelable, ISafetyEquals<Float, String>
{

    public static final Creator<SafetyFloat> CREATOR = new Parcelable.Creator<SafetyFloat>() 
    {
        /**
        * Read the serialized concrete strategy from the parcel.
        * @param in The parcel to read from
        * @return An SafetyByteArray
        */
        public SafetyFloat createFromParcel(final Parcel in) 
        {
            // Read serialized concrete strategy from parcel
            return (SafetyFloat) in.readSerializable();
        }
    
        /**
         * Required by Creator
         */
        public SafetyFloat[] newArray(final int size) 
        {
            return new SafetyFloat[size];
        }
    };

    // serial version id
    // This ID is generated by Android. DON't change to upper case
    private static final long serialVersionUID = -7559608581335441720L;

    // original value
    private Float mOriginal = null;

    // diverse value
    private String mDiverse = null;

    /**
     * The default constructors. The variable that initialed by this
     * constructors must call set() function before call get function.
     */
    public SafetyFloat()
    {
        // Do nothing for the no argument constructor
    }

    /**
     * Constructs a new SafetyFloat with original data of Float type and diverse
     * data of String type. It will call set function to set the original value
     * and diverse value.
     * 
     * @param original [in] the original data type value
     * @param diverse [in] the diverse data type value
     */
    public SafetyFloat(final Float original, final String diverse)
    {
        set(original, diverse);
    }

    /**
     * Check the data integrity of original data by safetyEquals() function and
     * return the original data if the check result is SafetyBoolean.TRUE,
     * otherwise throw DataIntegrityException.
     * 
     * @return T [out] the original data type value
     */
    public final Float get()
    {
        final float result = mOriginal;

        final SafetyBoolean isEquals = safetyEquals(result, mDiverse);

        if (isEquals.getByte() != SafetyBoolean.TRUE.getByte())
        {
            throw new DataIntegrityException("the original value [" + result
                    + "] is different from diverse value [" + mDiverse + "]");
        }

        return result;
    }

    /**
     * Return the original value without the safety comparison.
     * 
     * @return T [out] the original data type value
     */
    public final Float getOriginal()
    {
        return mOriginal;
    }

    /**
     * Return the diverse value without the safety comparison.
     * 
     * @return T [out] the original data type value
     */
    public final String getDiverse()
    {
        return mDiverse;
    }

    /**
     * Set the original data and diverse data and check the integrity of
     * original data by safetyEquals() function. Throw DataIntegrityException if
     * check result of safetyEquals() is SafetyBoolean.FALSE.
     * 
     * @param original [in] the original data
     * @param diverse [in] the diverse data (must be the negative value of
     *            original data)
     * @return void [out]
     */
    public final void set(final Float original, final String diverse)
    {
        mOriginal = original;
        mDiverse = diverse;

        // check data integrity
        final SafetyBoolean isEquals = safetyEquals(mOriginal, mDiverse);
        
        if (isEquals.getByte() != SafetyBoolean.TRUE.getByte())
        {
            throw new DataIntegrityException("the original value ["
                    + mOriginal + "] is different from diverse value ["
                    + mDiverse + "]");
        }
    }

    /**
     * Return SafetyBoolean.TRUE if the compare result of compareOriginal() and
     * compareInverse() are both true Otherwise return SafetyBoolean.FLASE.
     * 
     * For string comparison, it will convert the original data to String type
     * and call compareOriginal() and compareInverse() for comparison.
     * 
     * @param original [in] the original data
     * @param diverse [in] the diverse data
     * @return SafetyBoolean [out] Return SafetyBoolean.TRUE if the compare
     *         result of compareOriginal() and compareInverse() are both true
     *         Otherwise return SafetyBoolean.FLASE.
     */
    @Override
    public final SafetyBoolean safetyEquals(final Float original, final String diverse)
    {
        SafetyBoolean isResultOK = SafetyBoolean.FALSE;

        if ((original != null) && (diverse != null))
        {
            final String originalStr = String.valueOf(original);

            final SafetyBoolean isResultOKOriginal = compareOriginal(originalStr, diverse);
            final SafetyBoolean isResultOKInverse = compareInverse(originalStr, diverse);

            if ((isResultOKOriginal.getByte() == SafetyBoolean.TRUE.getByte())
                    && (isResultOKInverse.getByte() == SafetyBoolean.TRUE.getByte()))
            {
                isResultOK = SafetyBoolean.TRUE;
            }
        }
        return isResultOK;
    }

    /**
     * Compare the passed in original String data and diverse String data.<br />
     * 
     * Return SafetyBoolean.TRUE if all bytes of original data and diverse data
     * are totally same. Otherwise return SafetyBoolean.FALSE.
     * 
     * @param original [in] the original data of String type
     * @param diverse [in] the diverse data
     * @return SafetyBoolean [out] Return SafetyBoolean.TRUE if all bytes of
     *         original data and diverse data are totally same. Otherwise return
     *         SafetyBoolean.FALSE.
     */
    private SafetyBoolean compareOriginal(final String original, final String diverse)
    {
        SafetyBoolean isResultOK = SafetyBoolean.FALSE;

        int nCount = 0;

        final byte[] nOriginalBytes = original.getBytes();
        final byte[] nOiverseBytes = diverse.getBytes();

        final int nLength = nOriginalBytes.length;

        if (nLength == nOiverseBytes.length)
        {
            for (int i = 0; i < nLength; i++)
            {
                if (nOriginalBytes[i] == nOiverseBytes[i])
                {
                    nCount++;
                }
            }

            if (nCount == nLength)
            {
                isResultOK = SafetyBoolean.TRUE;
            }
        }

        return isResultOK;
    }

    /**
     * Compare the passed in original String data and diverse String data.<br />
     * 
     * Return SafetyBoolean.TRUE if there is no byte different between original
     * data and diverse data. Otherwise return SafetyBoolean.FALSE.
     * 
     * @param original [in] the original data of String type
     * @param diverse [in] the diverse data
     * @return SafetyBoolean [out] Return SafetyBoolean.TRUE if there is no byte
     *         different between original data and diverse data. Otherwise
     *         return SafetyBoolean.FALSE.
     */
    private SafetyBoolean compareInverse(final String original, final String diverse)
    {
        SafetyBoolean nResultOK = SafetyBoolean.FALSE;

        int nCount = 0;

        final byte[] nOriginalBytes = original.getBytes();
        final byte[] nDiverseBytes = diverse.getBytes();

        final int nLength = nOriginalBytes.length;

        if (nLength == nDiverseBytes.length)
        {
            for (int i = nLength - 1; i > 0; i--)
            {
                if (nOriginalBytes[i] != nDiverseBytes[i])
                {
                    nCount++;
                }
            }

            if (nCount == 0)
            {
                nResultOK = SafetyBoolean.TRUE;
            }
        }

        return nResultOK;
    }
    
    /**
     * "It is used for for some validation code -- in particular to implement Bundle.hasFileDescriptors()"
     * (Dianne Hackborn -- Android framework engineer)
     * Not implemented in SoloM_RCAPP.
     */
    public final int describeContents()
    {
        return 0;
    }
    
    /**
     * Flatten this object in to a Parcel.
     * 
     * @param dest The Parcel in which the object should be written.
     * @param flags Additional flags about how the object should be written. May
     *            be 0 or PARCELABLE_WRITE_RETURN_VALUE.
     */
    @Override
    public final void writeToParcel(final Parcel dest, final int flags)
    {
        dest.writeSerializable(this);
    }	
}

/*
 * ===========================================================================
 * 
 * Revision history
 * 
 * ===========================================================================
 */
// (10801 2014-06-09 09:54:09Z PhoenixCheng)
// ----------------------------------------------------------------------------
// [JIRA-ID]: ATOS-555
// [Comment]: Implements the Fix Point method to replace the floating point
// calculation and Safety for the bG, Insulin, Carbs data processing.
// (10801 2014-06-09 09:54:09Z PhoenixCheng)
// ----------------------------------------------------------------------------
// [JIRA-ID]: ATOS-272
// [Comment]: Update the package name in Header comment block
// (10801 2014-06-09 09:54:09Z PhoenixCheng)
// ----------------------------------------------------------------------------
// [JIRA-ID]:ATOS-267
// [Comment]:coding guideline
// (10801 2014-06-09 09:54:09Z PhoenixCheng)
// ----------------------------------------------------------------------------
// [JIRA-ID]:ATOS-267
// [Comment]:coding guideline
// (10801 2014-06-09 09:54:09Z PhoenixCheng)
// ----------------------------------------------------------------------------
// [JIRA-ID]:ATOS-267
// [Comment]:coding guideline
// (10801 2014-06-09 09:54:09Z PhoenixCheng)
// ----------------------------------------------------------------------------
// [JIRA-ID]: N/A
// [Comment]: Preform KEYWORD function of SVN for each source files. No Source
// code content will be changed
// (21021 2014-10-03 02:34:45Z HenryTso)
// ----------------------------------------------------------------------------
// [JIRA-ID]: ATOS-267
// [Comment]: Comply coding guideline
// (21467 2014-10-07 14:22:36Z HenryTso)
// ----------------------------------------------------------------------------
// [JIRA-ID]: ATOS-267
// [Comment]: Update for comply the coding guideline
// (21485 2014-10-08 05:38:44Z HenryTso)
// ----------------------------------------------------------------------------
// [JIRA-ID]: ATOS-267
// [Comment]: Comply coding guideline - Fix rule R17, R88, R100, R102, etc.
// (R24200 2015-11-16 06:13:22 StanleySu)
// ----------------------------------------------------------------------------
// ¦s¨ú³Q©Ú¡C
